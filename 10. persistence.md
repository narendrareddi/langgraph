{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "84a520da",
   "metadata": {},
   "source": [
    "# Persistence in LangGraph: Comprehensive Notes\n",
    "\n",
    "These notes are derived from the provided Hindi-English transcript, designed to help you understand the concept of **Persistence** in LangGraph without needing to rewatch the video. The notes cover the theoretical foundation, practical implementation, and benefits of persistence in LangGraph, ensuring a solid understanding for building complex LLM-based workflows.\n",
    "\n",
    "---\n",
    "\n",
    "## Table of Contents\n",
    "1. [Introduction to Persistence](#introduction-to-persistence)\n",
    "2. [Core Concepts of LangGraph](#core-concepts-of-langgraph)\n",
    "   - [Concept of Graph](#concept-of-graph)\n",
    "   - [Concept of State](#concept-of-state)\n",
    "3. [What is Persistence?](#what-is-persistence)\n",
    "   - [Definition](#definition)\n",
    "   - [Why Persistence is Needed](#why-persistence-is-needed)\n",
    "4. [How Persistence Works](#how-persistence-works)\n",
    "   - [Checkpointers](#checkpointers)\n",
    "   - [Threads](#threads)\n",
    "5. [Practical Implementation](#practical-implementation)\n",
    "   - [Example: Joke Generation Workflow](#example-joke-generation-workflow)\n",
    "   - [Code Walkthrough](#code-walkthrough)\n",
    "6. [Benefits of Persistence](#benefits-of-persistence)\n",
    "   - [Short-Term Memory](#short-term-memory)\n",
    "   - [Fault Tolerance](#fault-tolerance)\n",
    "   - [Human-in-the-Loop (HITL)](#human-in-the-loop-hitl)\n",
    "   - [Time Travel](#time-travel)\n",
    "7. [Key Takeaways](#key-takeaways)\n",
    "\n",
    "---\n",
    "\n",
    "## Introduction to Persistence\n",
    "- **Persistence** is a foundational concept in LangGraph, critical for building robust LLM-based workflows.\n",
    "- It serves as the basis for advanced features and is essential for understanding subsequent topics.\n",
    "- This topic covers:\n",
    "  - What persistence is.\n",
    "  - Why it is needed.\n",
    "  - How to implement it in code.\n",
    "  - Its practical benefits.\n",
    "\n",
    "By understanding persistence, you establish a solid foundation for advanced LangGraph concepts.\n",
    "\n",
    "---\n",
    "\n",
    "## Core Concepts of LangGraph\n",
    "To understand persistence, revisit two fundamental principles of LangGraph:\n",
    "\n",
    "### Concept of Graph\n",
    "- A **graph** represents a high-level goal decomposed into a set of tasks.\n",
    "- **Nodes**: Each node represents a task in the workflow.\n",
    "- **Edges**: Connections between nodes that define the execution order (e.g., Task 1 → Task 2).\n",
    "- Example: A workflow to process data might have nodes for data collection, processing, and output, with edges dictating the sequence.\n",
    "\n",
    "### Concept of State\n",
    "- **State** is a dictionary that stores critical data required for a workflow’s execution.\n",
    "- Example: In a chatbot workflow, the state might store messages exchanged between the AI and the user.\n",
    "- **Key Properties**:\n",
    "  - Every node in the graph can **read** from and **write** to the state.\n",
    "  - The state persists during the workflow’s execution but is typically erased once the workflow completes.\n",
    "\n",
    "These two concepts (graph and state) enable the creation of complex LLM-based workflows in LangGraph.\n",
    "\n",
    "---\n",
    "\n",
    "## What is Persistence?\n",
    "\n",
    "### Definition\n",
    "- **Persistence** in LangGraph refers to the ability to **save and restore the state of a workflow over time**.\n",
    "- It allows storing both **final** and **intermediate** state values, enabling access to these values even after the workflow ends.\n",
    "\n",
    "### Why Persistence is Needed\n",
    "- By default, LangGraph’s behavior is to erase the state once a workflow execution completes (i.e., state values are stored in RAM and lost after execution).\n",
    "- This makes it impossible to:\n",
    "  - Access past state values for future use.\n",
    "  - Resume a workflow from a specific point if it crashes or is interrupted.\n",
    "- **Persistence** changes this behavior by saving the state to a persistent storage (e.g., a database), allowing:\n",
    "  - Retrieval of state values at any time.\n",
    "  - Resumption of workflows from the point of interruption.\n",
    "  - Replaying or modifying past executions.\n",
    "\n",
    "---\n",
    "\n",
    "## How Persistence Works\n",
    "\n",
    "### Checkpointers\n",
    "- **Checkpointers** are the mechanism in LangGraph to implement persistence.\n",
    "- **Functionality**:\n",
    "  - Divide the workflow’s execution into **checkpoints**.\n",
    "  - Save the state’s values (intermediate and final) at each checkpoint to a database.\n",
    "- **Supersteps**:\n",
    "  - A **superstep** is a group of nodes executed in parallel or sequentially in a workflow.\n",
    "  - Each superstep corresponds to a checkpoint where state values are saved.\n",
    "- Example:\n",
    "  - In a workflow with nodes Start → Node 1 → Node 2 → End:\n",
    "    - Checkpoints are created at:\n",
    "      - Before Start (initial state).\n",
    "      - After Node 1 (intermediate state).\n",
    "      - After Node 2 (intermediate state).\n",
    "      - After End (final state).\n",
    "    - At each checkpoint, the state’s values (e.g., variables like `name` or `numbers`) are saved.\n",
    "\n",
    "### Threads\n",
    "- **Threads** are unique identifiers (Thread IDs) assigned to each workflow execution.\n",
    "- **Purpose**:\n",
    "  - Differentiate between multiple executions of the same workflow.\n",
    "  - Ensure state values from one execution are stored and retrieved separately from others.\n",
    "- Example:\n",
    "  - Execute a workflow with initial state `numbers = [1]` → Thread ID: `1`.\n",
    "    - State values (e.g., `[1, 2, 3]`) are saved against Thread ID `1`.\n",
    "  - Execute the same workflow with initial state `numbers = [6]` → Thread ID: `2`.\n",
    "    - State values (e.g., `[6, 7, 8]`) are saved against Thread ID `2`.\n",
    "  - To retrieve values from a specific execution, query the database with the corresponding Thread ID.\n",
    "\n",
    "This mechanism ensures that state values from different executions are isolated and retrievable.\n",
    "\n",
    "---\n",
    "\n",
    "## Practical Implementation\n",
    "\n",
    "### Example: Joke Generation Workflow\n",
    "- **Objective**: Build a sequential workflow that:\n",
    "  1. Takes a topic (e.g., \"pizza\").\n",
    "  2. Generates a joke using an LLM.\n",
    "  3. Generates an explanation for the joke using an LLM.\n",
    "- **Workflow Structure**:\n",
    "  - **Nodes**: `generate_joke`, `generate_explanation`.\n",
    "  - **Edges**: Start → `generate_joke` → `generate_explanation` → End.\n",
    "  - **State**: Dictionary with attributes:\n",
    "    - `topic`: String (e.g., \"pizza\").\n",
    "    - `joke`: String (the generated joke).\n",
    "    - `explanation`: String (the explanation of the joke).\n",
    "\n",
    "### Code Walkthrough\n",
    "Below is a summarized explanation of the code to implement persistence in this workflow:\n",
    "\n",
    "1. **Imports**:\n",
    "   - Import necessary libraries, including `langgraph.checkpoint.memory.InMemorySaver`.\n",
    "   - `InMemorySaver` is a checkpointer that saves state values in RAM (used for demos, not production).\n",
    "   - Production setups use database-backed checkpointers (e.g., PostgreSQL, Redis).\n",
    "\n",
    "2. **State Definition**:\n",
    "   ```python\n",
    "   from typing import TypedDict\n",
    "   class State(TypedDict):\n",
    "       topic: str\n",
    "       joke: str\n",
    "       explanation: str\n",
    "   ```\n",
    "\n",
    "3. **Node Functions**:\n",
    "   - `generate_joke`: Takes the `topic` from the state, uses an LLM to generate a joke, and updates the `joke` attribute in the state.\n",
    "   - `generate_explanation`: Takes the `joke` from the state, uses an LLM to generate an explanation, and updates the `explanation` attribute.\n",
    "\n",
    "4. **Graph Construction**:\n",
    "   ```python\n",
    "   from langgraph.graph import StateGraph, START, END\n",
    "   workflow = StateGraph(State)\n",
    "   workflow.add_node(\"generate_joke\", generate_joke)\n",
    "   workflow.add_node(\"generate_explanation\", generate_explanation)\n",
    "   workflow.add_edge(START, \"generate_joke\")\n",
    "   workflow.add_edge(\"generate_joke\", \"generate_explanation\")\n",
    "   workflow.add_edge(\"generate_explanation\", END)\n",
    "   ```\n",
    "\n",
    "5. **Adding Persistence**:\n",
    "   - Create a checkpointer:\n",
    "     ```python\n",
    "     from langgraph.checkpoint.memory import InMemorySaver\n",
    "     checkpointer = InMemorySaver()\n",
    "     ```\n",
    "   - Compile the graph with the checkpointer:\n",
    "     ```python\n",
    "     app = workflow.compile(checkpointer=checkpointer)\n",
    "     ```\n",
    "\n",
    "6. **Executing the Workflow**:\n",
    "   - Invoke the workflow with an initial state and a Thread ID:\n",
    "     ```python\n",
    "     config = {\"thread_id\": \"1\"}\n",
    "     app.invoke({\"topic\": \"pizza\"}, config=config)\n",
    "     ```\n",
    "   - The state values (`topic`, `joke`, `explanation`) are saved at each checkpoint.\n",
    "\n",
    "7. **Retrieving State**:\n",
    "   - Get the final state:\n",
    "     ```python\n",
    "     final_state = app.get_state(config)\n",
    "     # Output: {'topic': 'pizza', 'joke': 'Why did the pizza go to the doctor? Because it was feeling cheesy.', 'explanation': '...'}\n",
    "     ```\n",
    "   - Get the state history (all checkpoints):\n",
    "     ```python\n",
    "     history = app.get_state_history(config)\n",
    "     # Output: List of states at each checkpoint (e.g., empty state, topic set, joke set, explanation set)\n",
    "     ```\n",
    "\n",
    "8. **Multiple Executions**:\n",
    "   - Run the workflow again with a different topic (e.g., \"pasta\") and a new Thread ID:\n",
    "     ```python\n",
    "     config = {\"thread_id\": \"2\"}\n",
    "     app.invoke({\"topic\": \"pasta\"}, config=config)\n",
    "     ```\n",
    "   - Retrieve states for each Thread ID separately.\n",
    "\n",
    "---\n",
    "\n",
    "## Benefits of Persistence\n",
    "\n",
    "Persistence enables four key features in LangGraph workflows:\n",
    "\n",
    "### Short-Term Memory\n",
    "- **Purpose**: Store and retrieve past interactions (e.g., chatbot conversations).\n",
    "- **Use Case**: In a chatbot, users can:\n",
    "  - Start a new conversation.\n",
    "  - Resume a past conversation (e.g., from 3 days ago).\n",
    "- **How It Works**:\n",
    "  - Messages are stored in the state and persisted in a database using a Thread ID.\n",
    "  - To resume, retrieve the state using the Thread ID and continue the conversation.\n",
    "- **Example**: A user resumes a chat about a topic discussed earlier, and the chatbot loads the previous messages.\n",
    "\n",
    "### Fault Tolerance\n",
    "- **Purpose**: Resume a workflow from the point of failure without restarting from the beginning.\n",
    "- **Use Case**: A workflow crashes due to a server failure or API downtime.\n",
    "- **How It Works**:\n",
    "  - Checkpointers save the state at each superstep.\n",
    "  - If a crash occurs (e.g., at Node 2), the workflow can resume from the last checkpoint using the saved state and Thread ID.\n",
    "- **Example**:\n",
    "  - Workflow: Start → Node 1 → Node 2 (30-second delay) → Node 3 → End.\n",
    "  - Simulate a crash at Node 2 by interrupting the execution.\n",
    "  - Resume using:\n",
    "    ```python\n",
    "    app.invoke(None, config={\"thread_id\": \"1\"})\n",
    "    ```\n",
    "  - The workflow resumes from Node 2, not Start.\n",
    "\n",
    "### Human-in-the-Loop (HITL)\n",
    "- **Purpose**: Pause the workflow to wait for human input before proceeding.\n",
    "- **Use Case**: A workflow generates a LinkedIn post but requires human approval before posting.\n",
    "- **How It Works**:\n",
    "  - The workflow pauses at a checkpoint, saving the state.\n",
    "  - When human input is received (e.g., after hours or days), the workflow resumes from the checkpoint using the Thread ID.\n",
    "- **Example**:\n",
    "  - Workflow: Topic → Generate LinkedIn Post → Wait for Approval → Post to LinkedIn.\n",
    "  - Persistence ensures the workflow can wait indefinitely and resume when the human provides input.\n",
    "\n",
    "### Time Travel\n",
    "- **Purpose**: Replay or modify a workflow’s execution from a specific checkpoint.\n",
    "- **Use Case**: Debug a complex workflow by revisiting and re-executing specific steps.\n",
    "- **How It Works**:\n",
    "  - Each checkpoint has a unique **Checkpoint ID**.\n",
    "  - Retrieve the state at a specific checkpoint using:\n",
    "    ```python\n",
    "    state = app.get_state({\"thread_id\": \"1\", \"checkpoint_id\": \"<id>\"})\n",
    "    ```\n",
    "  - Update the state or re-execute from that checkpoint:\n",
    "    ```python\n",
    "    app.update_state({\"thread_id\": \"1\", \"checkpoint_id\": \"<id>\"}, {\"topic\": \"samosa\"})\n",
    "    app.invoke(None, {\"thread_id\": \"1\", \"checkpoint_id\": \"<id>\"})\n",
    "    ```\n",
    "- **Example**:\n",
    "  - Revisit the checkpoint where `topic = \"pizza\"` and change it to `topic = \"samosa\"`.\n",
    "  - Re-execute to generate a new joke and explanation for \"samosa\".\n",
    "  - This creates a new branch in the execution history, useful for debugging or testing alternate scenarios.\n",
    "\n",
    "---\n",
    "\n",
    "## Key Takeaways\n",
    "- **Persistence** allows saving and restoring a workflow’s state, enabling advanced features like resuming workflows, debugging, and memory management.\n",
    "- **Checkpointers** save state values at each superstep, ensuring both intermediate and final states are preserved.\n",
    "- **Threads** (Thread IDs) isolate state values for different executions, enabling retrieval of specific execution states.\n",
    "- **Practical Implementation**: Use checkpointers (e.g., `InMemorySaver` for demos, database-backed for production) and Thread IDs to persist state.\n",
    "- **Benefits**:\n",
    "  - **Short-Term Memory**: Store and resume chatbot conversations.\n",
    "  - **Fault Tolerance**: Recover from crashes by resuming from the last checkpoint.\n",
    "  - **Human-in-the-Loop**: Pause for human input and resume later.\n",
    "  - **Time Travel**: Replay or modify executions for debugging or experimentation.\n",
    "- **Next Steps**: Review the playlist’s chatbot video for a practical example of short-term memory and explore dedicated videos on HITL for deeper insights.\n",
    "\n",
    "---\n",
    "\n",
    "These notes provide a comprehensive understanding of persistence in LangGraph, covering theory, implementation, and practical benefits. By mastering this concept, you can build robust, fault-tolerant, and flexible LLM-based workflows."
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
